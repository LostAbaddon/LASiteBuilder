TITLE: 功能环、创新性、奥卡姆剃刀，以及无穷机
AUTHOR: LostAbaddon
DATE: 2021/05/14

[toc]

# 功能素

我们假定已经在一个由任意长字符串构成的空间中，存在所有可能存在的图灵机。从而，任意图灵机T都可以视为一个将字符串s映射到字符串t的映射。

反过来，我们将“将字符串s映射到字符串t”称为一个“__功能素__”，记为$T_{s,t}$，它是所有满足这一映射条件的图灵机的集合，而其中的每一台图灵机被称为该功能素的一个“__实现__”。

因此，我们可以利用图灵机来构造功能素的两个基本属性：

-	空间距离：$T_{s,t}$中所有图灵机长度（代码数）的最小值，记为$K(s,t)$；
-	时间距离：$T_{s,t}$中所有图灵机从输入s到最终输出t的执行步数的最小值，记为$R(s,t)$。

显然，$K(s,t)$和$R(s,t)$都是非对称的。

显而易见，字符串s的“K氏长度”其实就是从空字符串$\varnothing$到s的空间距离$K(\varnothing, s)$，也可记为$K(s)$。

由此，我们可以得到如下这样很自然的一组不等式：

$$
K(t) \ge K(s,t) \ge \max \left[ K(t) - K(s), 0 \right]
$$

对时间距离，我们还没有类似的结果可以很直观地给出。

将s映射到t的功能素记为F，则s被称为F的“输入”而t则被称为F的“输出”，分别记为$\mathrm{In}(F)$和$\mathrm{Out}(F)$。

如果两个功能A和B的输入不同，则这两个功能被称为**无关**的；如果A和B的输入和输出都相同，则A和B其实就是同一个功能；而如果A和B的输入相同但输出不同，则这两个功能被称为**矛盾**的。

# 功能

功能$\mathcal{F}$可以被视为一组任意元素都不矛盾的功能素$F_i = s_i \rightarrow t_i$构成的集合$\{F_i\}$，因此所有$F_i$的输入构成的集合被称为功能$\mathcal{F}$的输入$\mathrm{In}(\mathcal{F})$，而所有$F_i$的输出构成的集合被称为功能$\mathcal{F}$的输出$\mathrm{Out}(\mathcal{F})$，且很显然$|\mathrm{Out}(\mathcal{F})| \le \mathrm{In}(\mathcal{F})$。

我们可以很自然地得到一项功能的两个基本属性（我们先不考虑时间方面的问题）：

-	最短功能素空间距离：$k(\mathcal{F}) = \max \left[ K(s_i, t_i) \right]$
-	空间跨度：功能的实现集中长度最短的图灵机的长度，记为$K(\mathcal{F}) = \min \left( |T_i| | T_i \in \mathcal{F} \right)$。

显然关于这两个属性我们有如下不等式：

$$
M(\mathcal{F}) = c + \sum_i K(s_i, t_i) + K(s_i) \ge K(\mathcal{F}) \ge k (\mathcal{F})
$$

其中c是只和语言相关的、表示对输入做判断的分支语句的长度。最左边代表了最“简单粗暴”的一种构造功能的方式，即简单粗暴地将对输入做分支判断然后交给每个功能素来处理，在这种分支模式下，不同功能素之间没有任何关联与耦合，所以是一种非常“低效”的构造方式。

我们可以由此构造出功能的一个很有用的属性，即功能的“复杂度”：$C(\mathcal{F}) = \frac{K(\mathcal{F})}{k(\mathcal{F})}$。

很显然，如果两个功能素几乎无法耦合，那此时这两个功能素合成的功能的空间跨度$K$将更接近$I$；而如果两个功能素非常接近，则$K$更接近$k$，这也表示只需要对功能做一些很简单的增强就能实现新功能素所定义的功能。

为了进一步讨论功能复杂性的话题，我们需要从功能的“扩张”开始。

# 功能的扩张

假定两个功能$\mathcal{A}$和$\mathcal{B}$，且$\mathcal{A}$的所有功能素都是$\mathcal{B}$的功能素，则称$\mathcal{B}$是$\mathcal{A}$的一个“扩张”，记为$\mathcal{B} \vartriangleright \mathcal{A}$。

直白地说，就是功能的扩张拥有原功能的所有功能素，但还能实现更多的功能素。

因此，我们可以很直接地有这样的不等式：

$$
\mathcal{B} \vartriangleright \mathcal{A} \Rightarrow \begin{cases}
k(\mathcal{B}) &\ge &k(\mathcal{B})\\
K(\mathcal{B}) &\ge &K(\mathcal{B})
\end{cases}
$$

比较有趣的问题是扩张后复杂度到底是会增加还是减少。

但在讨论这个问题之前，我们先讨论一些别的和扩张相关的话题。

我们假定，两个功能$\mathcal{A}$和$\mathcal{B}$之间不存在扩张关系，但存在一个功能$\mathcal{C}$，它是这两个功能的扩张，即：

$$
\mathcal{C} \vartriangleright \mathcal{A} \land \mathcal{C} \vartriangleright \mathcal{B}
$$

这样，我们可以将功能$\mathcal{C}$称为$\mathcal{A}$和$\mathcal{B}$的“合功能”。两个功能的所有合功能中包含功能素最少的功能称为两者的“最小合功能”，它可以记为$\mathcal{C} = \mathcal{A} \oplus \mathcal{B}$，而这两个功能称为合功能的“子功能”。显然，我们有：

$$
\mathcal{C} = \mathcal{A} \oplus \mathcal{B} \Rightarrow \begin{cases}
k(\mathcal{C}) &= &\max \left[ k(\mathcal{A}), k(\mathcal{B}) \right]\\
K(\mathcal{C}) &\ge &\max \left[ K(\mathcal{A}), K(\mathcal{B}) \right]
\end{cases}
$$

如果$k(\mathcal{A}) > k(\mathcal{B})$，那显然有：

$$
C(\mathcal{C}) = \frac{K(\mathcal{C})}{k(\mathcal{C})} \ge \frac{K(\mathcal{A})}{k(\mathcal{A})} = C(\mathcal{A})
$$

而另一方面，对于最短功能素空间长度较短的功能$\mathcal{B}$，则有这样的关系：

$$
C(\mathcal{C}) = \frac{K(\mathcal{C})}{k(\mathcal{C})} \ge \frac{K(\mathcal{B})}{k(\mathcal{A})} = \frac{k(\mathcal{B})}{k(\mathcal{A})} C(\mathcal{B})
$$

两者结合起来就有：

$$
C \left( \bigoplus_i \mathcal{F}_i \right) \ge \frac{\max_i \left[ K \left( \mathcal{F}_i \right) \right]}{\max_i \left[ k(\mathcal{F}_i) \right]}
$$

这其实是一个很平庸的结果。另一个稍微有趣点的结果则是：

$$
C \left( \bigoplus_i \mathcal{F}_i \right) \ge \min \left[ C \left( \mathcal{F}_i \right) \right]
$$

也即，合功能的复杂度至少不小于子功能复杂度的最小值。

但这也表示，可能存在一类特殊的情况，当我们将一项功能拓展后，其复杂度相对某一子功能反而降低了。

因此，我们可以定义一项功能$\mathcal{F}$的“最复杂子功能”$\mathcal{M_F}$，它是$\mathcal{F}$的所有子功能中复杂度最高的那一组（可能不唯一）。

让我们现在回头来看到底什么是复杂度。

# 复杂度与创新

很显然，从定义就可以知道功能素的复杂度为1，也就是非常不复杂。而两个功能素构成的功能则有很多种情况，最理想的，就是功能素1的实现中最短的图灵机，恰好也是功能素2的实现中最短的图灵机，从而根据定义复杂度依然保持最小值1。比如，功能素1是将字符串“a”映射到字符串“a”，功能素2是将字符串“s”映射到字符串“s”，那么最简单同时也是最短的图灵机就是`s=>s`，且该图灵机对这两个功能素都是最短的，所以对这两个功能素构成的功能来说，也是最短实现，因此该功能的复杂度也一样为1。

但另一些情况就会比较复杂，比如计算功能素1依然是将字符串“a”映射到“a”，但功能素2是将字符串“100”映射到第100个黎曼非平庸零点，那么这样的功能的最短代码可能是这样的：

```javascript
(a) => {
	if (a === "a") return "a";
	if (a === 100) return P(a);
};
```

这里`P(a)`是计算第100个黎曼非平庸零点的最短程序。

这样的最短图灵机就是我们构造$I(\mathcal{F})$时所定义的“最简单粗暴”的形式，从而功能的复杂度将大增。

从这个例子可看出，如果功能的功能素彼此之间的“相似性”越小，则功能的复杂度将越大，功能所包含的“能力”也就越多。

因此，我们现在可以说合功能肯定拥有比子功能中拥有能力最少的那个所拥有的能力要多。而复杂度下降的情况则意味着，合功能中出现了原本子功能中被认为不够相似的孙功能之间的相似性或相通性。

这样，我们可以非常“形式”地给出“创新性”的定义：

合功能的复杂度与子功能复杂度最大值的差，即：

$$
N \left( \bigoplus_i \mathcal{F}_i \right) = \max_i \left[ C \left( \mathcal{F}_i \right) \right] - C \left( \bigoplus_i \mathcal{F}_i \right)
$$

这是一个过程依赖的量，即通过不同的子功能合并而成的相同的合功能，其创新性是不一样的。

而功能自身拥有过程无关的状态量被称为“创新度”，它是其最复杂子功能的复杂度与自身复杂度的差，即：

$$
N_0 (\mathcal{F}) = C(\mathcal{M_F}) - C(\mathcal{F})
$$

很显然，创新性与创新度都可能是负数，即最终的合功能复杂度比任何一个子功能的复杂度都要高，这并非不可能。

当然，由于K氏长度（也即算法复杂度）是不可计算的，所以上面的讨论会陷入空谈的泥潭中。我们可以选择一个更常用的方式，便是先选定可用的图灵机的集，然后上面的所有计算都限定在这些图灵机中。当我们选择的图灵机的集合足够“良好”的时候，则上述提到的所有计算就都有可能完成。

>	事实上，这里我们可以套用一些比较“诠释学”的观点：
>	-	前有：已有的功能
>	-	前见：选定的语言
>	-	前知识：选定的图灵机集

谈完功能的“语义”，我们下面回头来主要关注功能本身的结构特性。

# 功能环

我们先取一个字符集$\mathfrak{S} = \{s_i\}$，这样自然可以得到$\mathfrak{S}$上的所有可能功能素所构成的空间$\mathfrak{E_S}$。假定$|\mathfrak{S}| = n$，则显然$|\mathfrak{E_S}| = n^2$。我们下面取$\mathfrak{E_S}$的一个子集$\mathfrak{E}$，此后的所有讨论都在某个$\mathfrak{E}$中进行。

有了功能素的集合$\mathfrak{E}$，我们就可以定义功能的集合$\mathfrak{F}$，它是$\mathfrak{E}$的幂集的一个特殊的子集，因为任何字符串作为输入的功能素最多只能有一个，所以不同功能的数量有$n^{n + 1}$个（多出来的一个代表该字符串为输入的功能素不存在）。在$\mathfrak{F}$中我们可以定义一系列基础运算，它们将会把$\mathfrak{F}$变成一个有趣的东西。

>	这里有一个很重要的点。如果$\mathfrak{S}$是有限集，那$\mathfrak{E}$和$\mathfrak{F}$也是有限集，所以所有功能必然都可以用图灵机来表示。但如果$\mathfrak{S}$是可数无穷大的，那$\mathfrak{E}$虽然也一样是可数无穷大，但$\mathfrak{F}$却是不可数无穷大的，那此时就存在大量（实际上是不可数无穷个）功能是无法用图灵机来实现的。因此，我们之前说功能的实现都是图灵机，但现在看来功能的实现可以不是图灵机，而是更加宽泛的“映射机”。

我们下面来定义$\mathfrak{F}$中的一些基本运算。

两个功能素A和B，如果它们是无关的，则它们的“合”将构成一个功能$\{A,B\}$；而如果A和B矛盾，则它们的合取操作的后者。即：

$$
A \oplus B = \begin{cases}
\{B\} & A = B \lor 矛盾\\
\{A, B\} & 无关
\end{cases}
$$

由此我们可以给出两个功能$\mathcal{A}$和$\mathcal{B}$的合，即两者所蕴含的功能素中所有彼此无关或相等的部分保留，而有矛盾的部分保留输入后者的功能素。再加上，我们将不包含任何功能素的功能称为“零功能”，它在上述运算下显然是一个零元。因此，我们容易证明在这样定义的合运算$\oplus$将$\mathfrak{F}$构成一个非交换幺半群$(\mathfrak{F}, \oplus)$。而且，很容易证明这个幺半群是__幂等（idempotent）__的，因此只要选定一组功能素，则它的幂集在功能合作用下就能构成幂等幺半群。

接着，我们还可以定义$\mathfrak{F}$上的乘法$\otimes$。假定字符串$s$属于功能$\mathcal{A}$的输入，其输出为$\mathcal{A}(s)$，它如果是功能$\mathcal{B}$的输入，则最终的输出$\mathcal{B}(\mathcal{A}(s))$就是乘功能$\mathcal{A} \otimes \mathcal{B}$的运算结果，即功能素$s \rightarrow \mathcal{B}(\mathcal{A}(s))$是$\mathcal{A} \otimes \mathcal{B}$的功能素；而如果$\mathcal{A}(s)$不是$\mathcal{B}$的输入，则不向$\mathcal{A} \otimes \mathcal{B}$添加任何新的功能素。再加上$\mathfrak{S}$上将每个字符串映射到自身的恒等映射被定义为幺映射，这样定义的乘法$\otimes$构成了$\mathcal{F}$上的另一个幺半群$(\mathcal{F}, \otimes)$。我们将所有群元的输入的并记为$I_0$，并令$I_{i + 1} = \mathcal{F}(I_0)$，则有$I_{i + 1} \subseteq I_0$，且最后要么得到空集（此时相应的自乘结果为零功能），或者得到某个$I_n$满足$I_n = \mathcal{F} (I_n)$，此时对应的是偏幺映射，即对$I_n$中的字符串输入为恒等映射，而该集之外的字符串输入则无定义。

需要注意的是，虽然功能的加法$\oplus$和乘法$\otimes$在$\mathfrak{F}$上都构成幺半群，且零功能和任意功能的乘都是领功能，但$(\mathcal{F}, \oplus, \otimes)$并不构成半环，因为这里定义的加法是非交换的，而且更重要的是功能乘对功能合并不具有分配性，比如下面这三个功能：

$$
\mathcal{A} = \{ a \rightarrow b \}\\
\mathcal{B} = \{ a \rightarrow c \}\\
\mathcal{C} = \{ b \rightarrow d \}
$$

这样就有：

$$
\begin{align}
\mathcal{A} \oplus \mathcal{B} &= \mathcal{B}\\
(\mathcal{A} \oplus \mathcal{B}) \otimes \mathcal{C} = \mathcal{B} \otimes \mathcal{C} &= \{\}\\
\mathcal{A} \otimes \mathcal{C} &= \{ a \rightarrow d \}\\
\mathcal{A} \otimes \mathcal{C} \oplus \mathcal{B} \otimes \mathcal{C} = \mathcal{A} \otimes \mathcal{C} &= \{ a \rightarrow d \}
\end{align}
$$

所以，我们可以说$(\mathcal{F}, \oplus, \otimes)$构成了两个非交换幺半群，或者说整体构成一个*准幺半环（quasirig）*。我们形式地将这个空间称“__功能环__”，但要注意的是它并不是一个真的环，甚至都不是幺半环（rig）。

>	这里我们将带有零元和幺元的半环（semiring）称为幺半环（rig），类比于半群和幺半群的关系。

功能环上的乘法幺元在现在的加法定义下，其右加任意功能得到的都是自身，但左加则没有这个性质。而另一方面，如果我们将注意力放在功能对字符串的变换作用上，那我们很容易发现功能实际上是字符集上的一个偏函数，同时也可以被视为是一个态射，而字符串集和其上所有态射一起构成了一个范畴。

我们下面比较有兴趣的是作为两个幺半群的功能环本身的一些特性。

## 功能环的扩张

我们下面用$\left< \{ \mathcal{F}_i \} \right>$来表示由功能素集$\{ \mathcal{F}_i \}$在上面所定义的加法与乘法作用下构成的功能环（可能会需要补上零元和幺元）。

最简单的扩张方式，就是向功能集$\mathfrak{F}$添加一组新的功能$\{\mathcal{F}'_i\}$，以及通过添加这些新功能后能通过可数次功能加与功能乘的运算得到的所有衍生元素，这样得到的新功能集$\mathfrak{F}' = \mathfrak{F}\left[ \{ \mathcal{F}'_o \} \right]$就被称为原功能环的一个__扩张__，而$\{ \mathcal{F}'_o \}$被称为扩张元。

由于功能环的加法和乘法部分都是非交换的，所以我们显然无法利用域扩张或环扩张的知识来研究功能环的扩张性质。

从加法部分来看，扩张后的功能集至少应该包含如下功能集：

$$
\mathfrak{F}'_+ = \mathfrak{F} \oplus \left< \{ \mathcal{F}'_i \} \right>
$$

由加法的定义可知，无论新功能素是和原功能的所有功能素无关的，还是和部分功能素矛盾的，都可以写成如上形式。

而考虑上乘法后情况则比较复杂，我们无法简单写出一个表达式来。

一个最理想的状态，是拓展元和原功能环是“__正交__”的，即$\mathfrak{F} \otimes \{ \mathcal{F}'_i \}^* = \{ \mathcal{F}'_i \}^* \otimes \mathfrak{F} = \varnothing$，此时很显然有$\mathfrak{F}' = \mathfrak{F}'_+$，以及$\mathrm{Aut} \left[ \mathfrak{F}' : \mathfrak{F} \right] = \mathrm{Aut} \left( \left< \{ \mathcal{F}'_i \} \right> \right)$。

更复杂一点的情况下，我们可以认为新功能素的输入和原功能环的输出的交为空，即$\mathfrak{F} \otimes \{ \mathcal{F}'_i \}^* = \varnothing$，那么就有：

$$
\mathfrak{F}' = \mathfrak{F} \oplus \left( \left< \{ \mathcal{F}'_i \} \right> \otimes \mathfrak{F} \right)
$$

同理，如果新功能素的输出和原功能环的输入的交为空，那就有：

$$
\mathfrak{F}' = \mathfrak{F} \oplus \left( \mathfrak{F} \otimes \left< \{ \mathcal{F}'_i \} \right> \right)
$$

当然，对于更一般的情况，我们很难得到如此简洁的形式。

可以发现，对于上述两种情况，$\left< \{ \mathcal{F}'_i \} \right> \otimes \mathfrak{F}$或者$\mathfrak{F} \otimes \left< \{ \mathcal{F}'_i \} \right>$会给$\mathrm{Aut} \left( \left< \{ \mathcal{F}'_i \} \right> \right)$加上限制，所以实际上在这种非正交情况下，$\mathrm{Aut} \left[ \mathfrak{F}' : \mathfrak{F} \right]$会是$\mathrm{Aut} \left( \left< \{ \mathcal{F}'_i \} \right> \right)$的子群。

就如我们之前提到过的，功能环中功能的实现很可能不是图灵机能做到的，这也就是说所有图灵机构成的功能环只是一个很小的功能环，我们可以通过向其添加预言机来实现功能环的扩张。

比如说图灵机都可以通过字符串来表达，所以理论上我们可以建立一项功能，它将每一台图灵机（对应的字符串）映射到它的一些属性上，比如它是否停机。这样的映射总是可以做到的，但做到这一功能的机器却显然不可能是图灵机，而必须是更宽泛的映射机。而添加这样的映射机后，功能环就进行了一次扩张，从原本的图灵机功能环扩张到了拥有判断图灵机是否会停机的扩张功能环。

我们可以证明，**判断任意一个映射机（包括图灵机）是否是某个功能的实现，这个功能必然不是当前功能环的一项功能**，这就是[Rice定理](https://en.wikipedia.org/wiki/Rice%27s_theorem)在功能环上的一个体现，即__功能环上的Rice定理__。

>	这个定理的证明其实很容易，使用类似停机定理中用到的对角线法即可。比如如果存在一台映射机`checkF`可以判定任意当前功能环中映射机是否实现了指定的功能$\mathcal{F}$，于是我们令映射机`f`实现了该功能而`h`没实现该功能，接着就可以构造如下映射机（函数）：
```javascript
paradox = (s) => {
	if (checkF(paradox)) return h(s);
	else return f(s);
}
```
>	该映射机的功能很简单：如果`checkF`检测到`paradox`映射机自身能实现功能$\mathcal{F}$，则返回不能实现该功能的映射机`h`的返回值`h(s)`，否则返回能实现该功能的映射机`f`的返回值`f(s)`，因此显然构成了矛盾。

我们可以将上述功能写成两个功能的乘，前一个功能是将输入字符串前加上当前功能的功能判定值，第二个功能是根据第一位判定值来决定返回`f`还是`h`的输出。其中第一个功能建立在流程控制相关功能上，而第二个功能则只是一个有选择性的输出，因此这两个功能本身都很普通，但通过往功能环中添加功能验证功能，上述悖论结构就被构成了。

Rice定理告诉我们这么几件事：

1.	功能判定功能肯定不是当前功能环的功能；
1.	将原功能环通过加入功能判定功能进行扩张，扩张后的功能环中原功能判定功能将无法判定扩张后功能环中的任意实现是否实现了指定功能。
1.	悖论结构和功能环中具体有哪些功能无关的，只要存在一些最基础的流程控制功能即可。

这个情况就和停机定理一样。

也因此，我们理论上总可以无休止地拓张功能环——当然这么拓张的意义很可能不大，毕竟那些悖论结构看起来不过就是片汤话而已。

## 最小功能素集

很显然，两组功能素集可以张出（也即通过可数次功能加法与乘法构造出）完全相同的功能环，因此一个很自然的问题，就是一个给定功能环$\mathfrak{F}$最小可以由一个什么样的功能素集张成？我们用$\mathfrak{M_F}$表示功能环$\mathfrak{F}$的最小功能素集。所以对于功能环$\mathfrak{F}$，利用最小功能素集$\mathfrak{M_F}$就可以很自然地给出两个属性：

-	功能环的宽度：$W(\mathfrak{F}) = \left| \mathfrak{M_F} \right|$
-	功能环的复杂度：$K(\mathfrak{F}) = \sum_{\mathcal{F} \in \mathfrak{M_F}} K(\mathcal{F})$

因此功能环的扩张必然伴随着功能环最小功能素集的扩张。

下面，我们从功能环的结构（虽然也没写出什么有意义的内容）往回走，再来看看和复杂度相关的一些内容。

# 功能实现的难易程度

要衡量一项功能是否容易实现，可以有两个可度量的手段：

1.	在功能环$\mathfrak{F}$中，给定功能$\mathcal{F}$的实现映射机在功能环所有实现映射机中的数量占比$P_\mathfrak{F}(\mathcal{F})$；
1.	假定功能环底层的字符串所用到的所有可能字符都是随机出现的，随机出现字符的概率为$q$，则恰好出现能实现指定功能的概率$Q(\mathcal{F})$。

占比P依赖于功能环中功能集的选择，而出现概率Q则只依赖于底层字符集的选择。这里我们可以允许字符集中的特定字符可以对应到某些特殊功能的预言机，但即便如此P和Q的“适用范围”也是不一样的，毕竟映射机理论上允许无限长（甚至不可数无限长）字符串才能实现的功能，因此这些无限长映射机对Q的贡献精确为0，但在P的计算中却有无法忽视的贡献。

我们下面将所有讨论都局限在功能集为所有图灵机构成的全集$\mathfrak{T}$这一条件下。

由于Rice定理的限制，我们几乎不可能将实现一个功能的所有图灵机都穷尽，所以实际上要计算P，我们还需要对$\mathfrak{T}$做进一步约束，我们从“所有长度不超过n的图灵机构成的集合”$\mathfrak{T}_n$开始，相应的占比与出现概率我们分别记为$P_n$和$Q_n$。

首先很显然的，就是$P(\mathcal{F})$应该和该功能的空间跨度$K(\mathcal{F})$有一定的相关性。

在$\mathfrak{T}_n$中，所有图灵机的数量为$N_n = \sum_{i = 0}^n D^i = \frac{D^{n + 1} - 1}{D - 1}$。

接着，我们总可以在图灵机上做一些没有实际作用但能占用大量空间的“后缀”，比如在最后一个接受并返回结果的语句之后加上大量无用字符串，那么此时这些字符串根本不会被执行到，但却能生成新的图灵机。我们将真正实现功能的图灵机称为“功能部分”，而无用字符串是“后缀部分”，则显然任何只包含功能部分的图灵机可以形成一个等价类，等价类中的图灵机的功能部分相同而后缀部分各不相同。

对于这样的图灵机类$\{ f \}$，其在$\mathfrak{T}_n$中的元素数量为$C_{\{ f \}} = \sum_{i = 0}^{n - |f|} D^i = \frac{D^{n - |f| + 1} - 1}{D - 1}$。因此，实现指定功能的图灵机的数量就是对所有实现的等价类的元素的总和，因为这些等价类的交显然为空。所以形式上我们有如下结果：

$$
P_n (\mathcal{F}) = \sum_i \frac{D^{n - |f_i| + 1} - 1}{D^{n + 1} - 1} \approx \sum_i D^{- |f_i|}
$$

显然在这个求和中，单项最大的是K氏长度最短的图灵机所处的等价类，而且乍看起来似乎更可以进一步表达为$P_n (\mathcal{F}) \approx D^{- K(\mathcal{F})}$（我们几乎可以确定，任何功能的最短实现都是唯一的，不会出现两个图灵机同时是最短实现）。

为了明确这个问题，我们可以将不等式写为：

$$
P_n (\mathcal{F}) = \frac{D^{n + 1}}{D^{n + 1} - 1} \left( \sum_i D^{- |f_i|} - \frac{C_n}{D^{n + 1}} \right) > \frac{D^{n + 1}}{D^{n + 1} - 1} D^{- K (\mathcal{F})} - \frac{C_n}{D^{n + 1} - 1} = \hat P_n (\mathcal{F})
$$

其中$C_n$是功能部分的长度不超过n的图灵机等价类的数量，而$\hat P_n (\mathcal{F})$则是有最短实现图灵机所贡献的占比。我们可以进一步用$c_n$来表示功能部分的长度恰好为n的图灵机的等价类的数量，则有：

$$
P_n (\mathcal{F}) = \frac{D^{n + 1}}{D^{n + 1} - 1} \left[ \sum_{l = K(\mathcal{F})}^n c_l \left( D^{- l} - \frac{1}{D^{n + 1}} \right) \right]
$$

因此功能占比和最短实现占比的差异为：

$$
\frac{P_n (\mathcal{F}) - \hat P_n (\mathcal{F})}{\hat P_n (\mathcal{F})} = \left( D^{- K(\mathcal{F})} - \frac{1}{D^{n + 1}} \right)^{-1} \left[ \sum_{l = K(\mathcal{F}) + 1}^n c_l \left( D^{- l} - \frac{1}{D^{n + 1}} \right) \right]
$$

所以在全集$\mathfrak{T}$中就是：

$$
\frac{P (\mathcal{F}) - \hat P (\mathcal{F})}{\hat P (\mathcal{F})} = \sum_{l = K(\mathcal{F}) + 1}^n c_l \left( D^{K(\mathcal{F}) - l} \right)
$$

因此，功能的占比能用其最短实现占比来合理表示的条件就可以表示为$c_l \left( D^{K(\mathcal{F}) - l} \right) \ll 1$，而且一般而言之一条件几乎总是可以满足的——

让我们令$N_n$代表所有长度不超过$n$的图灵机构成的集合，其大小显然为$N_n = \frac{D^{n + 1} - 1}{D - 1}$。接着，我们将功能根据占比由大到小排列，从而$P_n (f_{i}) \ge P_n (f_{i + 1})$。然后，我们令$N_n (p)$来表示所有占比不小于$p$的图灵机的总数，$j$则代表占比不小于$p$的功能的总数，因此就有：

$$
P(f_j) \ge p > P(f_{j + 1})\\
N_n (p) = N_n \sum_{i = 1}^j P(f_i)
$$

由于数列是占比降序的，所以显然我们有$N_n (p) \ge j p N_n$，也即：

$$
j \le \frac{N_n (p)}{p N_n} \le \frac{\omega_n}{p}
$$

这里$\omega_n$是长度不超过n的图灵机的停机概率，且一般而言上述两个不等式的两个等号不可能同时取到，因为前面一个等号取在占比最大时，而后面一个等号取在占比最小时，因此我们几乎可以满怀把握地说：$j < \frac{\omega_n}{p}$。

这也就是说，我们如果有一个映射机，可以列出所有长度不超过n的图灵机，并对其功能进行归类与排序，根据类元素多少降序排列，那么在至多在不超过$\frac{\omega_n}{p}$的位置就能找到实现占比为$p$的功能的图灵机。

>	当然，我们必须注意到，上述功能显然是图灵机无法实现的。列出所有长度不超过n的图灵机不难，但要对其进行功能归类则很难——还记得停机不可判定定理和Rice定理么？至少这个映射机绝对不可能在长度不超过n的图灵机集中找到。

因此上述搜索指定功能的实现的程序中，大部分都是和枚举图灵机相关的，而真正负责找出目标图灵机的，是系数$\frac{\omega_n}{p}$，或者我们更可以用$\frac{1}{p}$，因为$\omega_n$是不可计算的。也就是说，这样一个程序的长度为$- \log_D p + c$，其中c是一个非常大的、和$p$无关而只和语言与流程控制相关的常数。

最后，由于这个程序可以找到目标功能的实现图灵机，所以有：

$$
\log_D P_n (\mathcal{F}) \le - K(\mathcal{F}) + c
$$

也即：

$$
D^{- K(\mathcal{F})} < P_n (\mathcal{F}) \le D^{c - K(\mathcal{F})}
$$

也即，如果上述寻找功能实现的程序可以用图灵机表达，那么c就是一个有限值（可能很大），那么功能占比基本还是随着复杂度（功能的空间跨度）的增加而指数下降的，尤其当两个功能的复杂度的差超过该常数c时，那低复杂度的功能肯定比高复杂度的功能的占比更高。

这就是功能环上的__Levin自指编码定理__。

但，当c很大时，两个功能的复杂度即便差异很大（但依然小于c），功能占比也未必和功能复杂度相关。而当上述功能实现搜索功能无法用图灵机实现时，则功能占比和功能复杂度之间无必然联系。

而且，只要c不是0（显然c不可能是0），那[奥卡姆剃刀](https://en.wikipedia.org/wiki/Occam%27s_razor)在功能环的AIT上就未必成立，因为除非最小复杂度功能的复杂度与次小复杂度功能的复杂度的差异大到比c大，否则复杂度较小的功能的占比未必会比次小的更大。也就是说，在复杂度足够接近的情况下，简单的功能未必更容易出现。

当然，既然要谈出现，那只谈占比显然就不够了，所以让我们转向功能的另一个有趣的性质——出现概率$Q(\mathcal{F})$。

## 随机字符串集中功能的出现概率与实现概率

假定一台图灵机$T$的长度为$|T|$，那么在完全随机的情况下，它在一个字符随机出现的空间中恰好以正确的形式随机涌现出来的概率自然就是$q^{|T|}$。对于一个功能来说，字符随机出现的情况下恰好能出现实现该功能的图灵机的概率自然就是：

$$
Q(\mathcal{F}) = \sum_{f_i \in \mathcal{F}} q^{|f_i|}
$$

和之前一样，我们总可以把图灵机$f_i$分解为功能部分$f_{0, i}$和后缀部分，那么上面的结果就可以调整为：

$$
\begin{align}
Q(\mathcal{F}) &= \lim_{n \rightarrow \infty} \sum_{i} \sum_{j = 0}^{n - |f_{0, i}|} q^{|f_{0, i}| + j} D^j\\
&= \lim_{n \rightarrow \infty} \sum_{i} q^{|f_{0, i}|} \frac{1 - ( D q )^{n + 1 - |f_{0, i}|}}{1 - D q}\\
&= \frac{1}{1 - D q} \sum_{i} q^{|f_{0, i}|}\\
\end{align}
$$

由于求和部分与$P(\mathcal{F})$相同，所以我们可以很容易得到结果：

$$
\frac{1}{1 - D q} q^{K(\mathcal{F})} < Q (\mathcal{F}) \le \frac{1}{1 - D q} q^{K(\mathcal{F}) - c}
$$

这个问题还有一个更加“激进”的变化——

假定，现在每个字符单位时间里有概率$p$发生改变并导致映射机停机，同时单位时间里任意映射机都可以执行$T$步，那么指定功能在这个空间中执行完毕的概率有多大？

当然，这个提法本身非常粗糙，因为图灵机中字符的调整本身并不必然导致停机，最显然的例子就是其后缀部分，这部分的字符串改变不会对程序的执行带来任何影响。但如果真要这计算的话，那情况将会变得非常复杂，我们必须考虑所有程序彼此之间的“字符调整间距”，从而使得计算变得根本无法进行。

因此我们下面假定通用图灵机在读入的图灵机的任何字符发生改变的时候就会停机，无论是否影响该图灵机的执行。

这样，我们下面就可以得到一个较为准确可信的功能实现概率了：

$$
\begin{align}
F(\mathcal{F}) &= 1 - \prod_{f \in \mathcal{F}} \left[ 1 - ( 1 - p )^{\frac{|f| R(f)}{T}} \right]\\
&= 1 - \prod_{f_i} \lim_{n \rightarrow \infty} \prod_{l = 0}^{n - |f_i|} \left\{ 1 - ( 1 - p )^{\frac{R(f_i)}{T} \left[ |f_i| + l \right]} \right\}^{D^l}\\
&= 1 - \prod_{f_i} \lim_{n \rightarrow \infty} \prod_{l = 0}^{n - |f_i|} T \left( f_i, l \right)\\
T \left( f_i, l \right) &= \left\{ 1 - ( 1 - p )^{\frac{R(f_i)}{T} \left[ |f_i| + l \right]} \right\}^{D^l}\\
\end{align}
$$

我们可以先关注$\lim_{l \rightarrow \infty} T \left( f_i, l \right)$，因为如果这个结果为0，那就表示所有能实现该功能的无限长映射机全部都停机的概率为0，从而该功能必然会实现；而如果这个结果为1，那就表示我们只需要考虑能实现该功能的有限场图灵机的全部停机概率即可。而这个判定条件为$D (1 - p)^{\frac{R(f_i)}{T}} < 1$，这个条件满足时无限长图灵机全部停机的总概率为1，否则为0。当然，还有一个临界情况那就是$D (1 - p)^{\frac{R(f_i)}{T}} = 1$，此时结果为$\frac{1}{e}$，但由于还有一个$l$从0到无穷的连乘，所以最后的总体效果和小于1的情况相同，我们就不另做分析了。

也就是说，如果字符保持不变的概率过大，那等价类的大小将完全“抵消”等价类中图灵机发生变动而导致停机的概率。而只有当字符随机变化并导致停机的概率足够大时，无穷长映射机的贡献才会被完全消除。

这也就是说，从定性的角度来说，如果随机改变的几率不大，那任意功能的映射机只要出现就总可以执行成功；而如果随机改变的概率足够大，那有些功能的映射机即便出现了，也未必可以成功执行到最后从而实现该功能。

我们下面就来看这个随机改变的概率足够大的情况，此时当l趋向无穷时候，代表后缀部分长度为l的等价类元素对功能实现会停机从而无法实现功能的概率$T(f_i, l)$会收敛到1，也就是说后缀部分足够长的部分对功能实现的总贡献可以无视。

在这个情况下，上述等价类停机总概率可以写为：

$$
\begin{align}
T \left( f_i, l \right) &= \left\{ 1 - ( 1 - p )^{\frac{R(f_i)}{T} \left[ |f_i| + l \right]} \right\}^{D^l}\\
&\approx 1 -  ( 1 - p )^{\frac{R(f_i) |f_i|}{T}} \left[ D ( 1 - p )^{\frac{R(f_i)}{T}} \right]^l\\
\therefore \lim_{n \rightarrow \infty} \prod_{l = 0}^{n - |f_i|} T \left( f_i, l \right) &\approx 1 -  ( 1 - p )^{\frac{R(f_i) |f_i|}{T}} \lim_{n \rightarrow \infty} \sum_{l = 0}^{n - |f_i|} \left[ D ( 1 - p )^{\frac{R(f_i)}{T}} \right]^l\\
&= 1 -  \frac{( 1 - p )^{\frac{R(f_i) |f_i|}{T}}}{1 - D ( 1 - p )^{\frac{R(f_i)}{T}}}\\
\therefore F (\mathcal{F}) &\approx 1 - \prod_{f_i} \left[ 1 -  \frac{( 1 - p )^{\frac{R(f_i) |f_i|}{T}}}{1 - D ( 1 - p )^{\frac{R(f_i)}{T}}} \right]\\
&\approx \sum_{f_i} \frac{( 1 - p )^{\frac{R(f_i) |f_i|}{T}}}{1 - D ( 1 - p )^{\frac{R(f_i)}{T}}}
\end{align}\\
$$

乍看之下，我们会认为等价类功能部分的空间长度与时间长度的乘积$|f_i| R(f_i)$最小的映射机会贡献出连乘中最主要的部分，但实际情况会复杂不少，因为$F(\mathcal{F})$的求和部分随着$|f| R(f)$的增加而减少，但同时也随着$R(f)$的增加而减少，所以如果$f_0$是$|f_0| R(f_0)$最小的映射机，而$f_1$是乘积次小的映射机，如果$R(f_0) - R(f_1)$足够大，比$|f_1| R(f_1) - |f_0| R(f_0)$更大（实际情况当然要更复杂一点），那乘积次小项对功能实现概率的贡献将比最小项更重要。因此，对等价类的求和很显然还和等价类的具体结构有关，而不能只考虑某个“主要项”。

当然，我们还可以将涌现概率$q$也考虑上去，这样执行概率就不单单是映射机出现后能一直维持不被破坏一直到执行完功能，更能涵盖其本身涌现出来的情况，从而能表达功能能涌现并一直持续到执行成功的概率。更进一步，我们还可以考虑只有总执行时间长度$t$，这样就必须将所有执行时长在$t$以上的都去除（还好，等价类中的映射机的执行时长都是相同的），所以现在的实现概率为：

$$
\tilde F (\mathcal{F}, t) \approx \sum_{R(f_i) \le t} \frac{q^{|f_i|} ( 1 - p )^{\frac{R(f_i) |f_i|}{T}}}{1 - D q ( 1 - p )^{\frac{R(f_i)}{T}}}
$$

在这个定义下，由于功能的最短实现往往都具有较长的执行步数，所以在$t$不够大的时候最短实现往往无法提供任何贡献。而当t足够大时，结果实际上回了之前定义的实现概率上，只不过需要将执行步数调整为$R' = R + \frac{\ln q}{\ln (1 - p)} T$，其它都差不多，这里就不多讨论了。

总体来说，对功能的实现概率而言，我们并不能简单地看功能的复杂度或功能实现所需的步数，而是取决于该功能在整个功能环中其等价类与实现的具体结构。

下面我们来总结一下。

我们前面总共得到了功能环上三个重要的和功能本身相关的概率：

-	占比$P(\mathcal{F})$：能实现指定功能的映射机在所有映射机中的占比
-	涌现概率$Q(\mathcal{F})$：能实现指定功能的映射机在随机字符涨落中涌现出来的概率
-	实现概率$\tilde P(\mathcal{F})$：能实现指定功能的映射机在随机字符中涌现出来后一直留存到完成功能的概率

这三个概率分别从静态、动态涌现与功能实现三个视角反应了一项功能在整个功能环中的“重要性”。

其中，前两个随着功能复杂度的升高而指数衰减，但只有当两个功能的复杂度之差大于一个和功能无关的常数时，我们才能有把握说复杂度更低的功能更容易出现，否则功能出现的概率和复杂度就没有必然的联系。

而第三个概率则更奇妙——功能能够通过随机字符涨落而实现（并非仅仅出现）的概率，和其复杂度没有必然联系，在一般情况下和复杂度与时间跨度的乘积会有一定的关联，但大多数时候两者也无关。因此在功能实现的视野看来，功能能否实现是和功能本身到底实现了什么功能有关，而和功能的复杂度以及执行步数没有必然联系。

因此，我们总结下来可以这么说：**从静态角度来说，功能出现的概率大概可以说在大尺度跨度上体现了奥卡姆剃刀原则，但从动态的功能实现的角度来说，功能实现的概率和奥卡姆剃刀没有任何关联。**

# 对无限编码

对于一个拥有D个字符空间来说，所以任意字符串$s=\{s_i\}$总可以表达为一个D进制数$\sum_{i=1}^n D^{i - 1} s_i$——这是一种编码方式，当然还可以有别的编码方式，比如哥德尔编码$\sum_{i=1}^n p_i^{s_i}$。

字符串长度不超过n的空间，其中元素总共有$\frac{D^{n + 1} - 1}{D - 1}$。但同时我们知道，我们总可以为字符串进行恰当的编码，使之映射到自然数上。当n趋向无穷$\aleph_0$时，我们会发现允许存在的字符串的数量其实趋向不可数无穷$\aleph_1$，但编码却只能到可数无穷$\aleph_0$，这便说明存在不可数无穷多个“不可定义”的字符串。

当然，这不过是一个大家早就熟知的小把戏而已，真正有趣的是：图灵机建立在字符串之间的映射上，但却没这些映射这么多，因为图灵机也是可枚举的，所以只有可数多个，但字符串之间的映射则可以有不可数无穷多$\aleph_1$个。

因此，这就是说，如果我们考虑能将接受可数无穷多个字符串为输入并给出不唯一输出的所有映射，那么这些映射中有可数无穷多个是可以用图灵机表达的，但还有不可数无穷多个映射是无法用图灵机表达的——它们只能更加使用更加宽泛的“映射机”来表达。

这一内容我们之前讨论过了。

但，如果我们将图灵机可接受的字符集范围做一个扩展呢？

比如，我们允许图灵机将特殊字符$\digamma$当做$\sqrt{2}$？

这做法本身其实没任何新奇的，现代符号计算型数学计算软件都能做到这点。

事实上，添加有限个特殊符号来表示特定的数，无论这个数是无理数、超越数、虚数、不可计算数甚至不可定义数，都无法将图灵机的算力进行质的飞跃式的拓展。

除非我们能向图灵机可接受的字符集添加无穷多个新字符——但我们知道，传统图灵机的形式定义七元组中，一般都要求字符集、状态空间是有穷的，所以这种添加的方式就注定了我们将面对不是图灵机的一类东西。

好了，现在让我们假定，我们已经为图灵机添加了可数无穷个新符号了，我们将这种新的映射机称之为“无穷机”。现在，无穷极的总数量为$\aleph^n$，这里n是无穷机的长度，即其包含的符号数量，显然它和字符集是等势的，只要无穷机的长度是有限的。

这就是说，只要我们依然要求映射机所包含的符号数量是有限的，那么即便允许无穷机可以使用的符号集是可数无穷大，无穷机也无法穷尽所有映射机。只有当我们允许无穷机使用的符号集包含不可数无穷个符号时，无穷机才和映射机等势——但也未必表示能穷尽。

因此，我们希望能构造出一种能接受不可数无穷多个字符或有限个字符但字符集为不可数无穷大的输入的无穷机，它或许有可能能构造出比传统图灵机的功能环在功能上更强的功能环——当然，这样的无穷机显然不是图灵机，因为在传统标准图灵机定义中，字符集和状态空间都必须是有穷的。

为此，我们考虑向字符集添加$\aleph_1$个新符号的方式——最简单的做法就是使用模拟信号，那是一种连续信号，所以自然可以被视为有$\aleph_1$个彼此不同的符号，只要我们暂时忽略在实际制造这种无穷机时必然会遇到的分辨率限制的问题。

符号可以分为很多种，一部分是用于流程控制，一部分是用于寄存器变量，还有一部分是作为数据，但我们总可以将它们编码为$[0, 1]$区间内的一个实数。

比如，总共存在$L$类不同的符号，如果一类符号是有限的，那就可以将其映射为$[0, 1]$上的一组等间距区间；而如果一类符号有无限个，那自然可以通过映射$\frac{x}{x + 1}$将其映射到$[0, 1)$上。因此$L$类信号总可以编码为$[0, L]$中的实数，进而总是可以编码为$[0, 1]$上的实数。

这样，我们就可以通过一组实数来表示$\aleph_1$个不同的信号——也就是说，这样定义的无穷机理论上可接受的字符串的字符集大小为不可数无穷大，准确地说是$\aleph_1$。

如果要和图灵机的情况做类比的话，我们下面一个最重要的问题就是要分析无穷机的“代码长度”——而由于现在存在不可数无穷多个符号，所以任意我们想要的实数输出都可以用一个符号直接给出而不用考虑具体生成过程。

但，如果我们考虑的是具体的映射关系，即对于输入的一组实数，依次给出符合功能要求的一组实数，这样的功能在无穷机上就几乎不可能通过简单的分支来完成。因此，无穷机的长度会比图灵机的长度小很多，因为数据生成的逻辑过程可以忽略，而更多考虑的是输入和输出之间的功能逻辑关系。

但换一个角度来想的话，无穷机的代码长度依然是可数的，所以很多图灵机功能环上的悖论问题在无穷机功能环上也依然会出现。比如我们依然无法构造任何一台无穷机，它可以计算任意无穷机的K氏复杂度或者说最短长度——事实上，这样的功能必须要求长度为不可数无穷的映射机。

也就是说，无穷机功能环虽然比图灵机功能环大了不少，但功能拓展上，其拓张而来的威力几乎都只是源自其引入的新的不可数无穷多个符号，所以可以处理更多的数据，但在实际功能拓展上却并不多。

要能在功能上有质的飞越，我们很可能需要不单单能处理无限字符集中符号的无穷机，还需要这种无穷机能蕴含并处理“无穷多的指令”——这样的东西理论上当然可以构造，但实际上却几乎不可能做出来。

因此，让我们从理论回到现实，下面最主要的问题就成了：__物理过程和人脑是否可能是某种意义上的无穷机？__

虽然，从实操角度来说，我们对所有输入和输出都可以做“栅格化”，将其映射到离散值上，从而我们并不真的需要处理不可数无穷大的符号集，但就如此前所说的，这样的映射依然可能在数量少超过图灵机的数量。

也就说，存在一定的可能性，物理过程和人脑的确是某种形式上的无穷机，从而不是图灵机可以描述的。

当然，这也不过是一种美好的愿景而已，未必是实际情况，我们只能等着瞧了。
